/* lex.h - Lexical analyzer

   Copyright (c) 2010-2011 Jukka Lehtosalo

   Alore is licensed under the terms of the MIT license.  See the file
   LICENSE.txt in the distribution.
*/

/* Lexical analyzer and symbol table management code. The lexical analyzer
   converts a string representing the source file to an array of tokens. */

#ifndef LEX_H_INCL
#define LEX_H_INCL

#include "symtable.h"
#include "token.h"
#include "value.h"


struct AToken_;


typedef union {
    int num;
    AValue val;
    struct ASymbol_ *sym;
    struct AToken_ *nextBlock;
} ATokenInfo;


/* A single token generated by the lexical analyzer. */
typedef struct AToken_ {
    ATokenInfo info;
    unsigned short lineNumber;
    unsigned char type;
} AToken;


/* Source file encoding */
typedef enum {
    AENC_ASCII,    /* 7-bit ASCII (default) */
    AENC_LATIN1,   /* ISO 8859-1 (identity encoding) */
    AENC_UTF8      /* UTF-8 */
} AEncoding;


void AInitializeLexicalAnalyzer(void);

ABool ATokenize(const unsigned char *src, const unsigned char *srcEnd,
                AToken **tokenList, AToken **tokPtr, AEncoding *encoding);
ABool AAddEofToken(AToken *tok);
void AFreeTokens(AToken *tok);

ABool ATokenizeStr(const char *str, AToken **tok);

/* Returns the hash value of the symbol SYM. */
unsigned AGetSymbolHashValue(struct ASymbol_ *sym);


#define AAdvanceTok(tok) \
    ((tok)[2].type == TT_EOB ? (tok)[2].info.nextBlock : (tok) + 1)

#define AIsEndOfTokenBlock(tok) \
    ((tok)[2].type == TT_EOB)


/* Size of temporary buffer used for tokenizing names (etc.). */
#define A_TOKENIZE_BUF_LENGTH 256


#endif
