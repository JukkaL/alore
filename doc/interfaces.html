@head
@module std
@title Interfaces

<p>The <tt>std</tt> module defines several interfaces. They are
described in this section. Note that a class may implement multiple
interfaces.

<h2>Interface <tt>Sequence&LT;T&gt;</tt></h2>

@class-hidden Sequence

<p>An object that implements <tt>Sequence</tt> can be used as a read-only
sequence. The interface includes the following operations:

@fun length() as Int
@desc Return the length of the sequence.
@end

@fun _get(index as Int) as T
@desc Return the element at the specified index. The first element has index 0,
      the second 1, etc.
      @note Negative index values need not be supported.
      @end
@end

<p>@ref{Array} and @ref{Str} implement <tt>Sequence</tt>. Note that
<tt>Array</tt> objects are mutable.

<h2>Interface <tt>Iterable&lt;T&gt;</tt></h2>

@class-hidden Iterable

<p>Iterable objects provide the <tt>iterator</tt> method:

@fun iterator() as Iterator<T>
@desc Return an iterator that iterates over all the objects in a composite
      object.
@end

<p>@ref{Str}, @ref{Range}, @ref{Array}, @ref{Map}, @ref{Set} and @ref{Stream}
objects implement <tt>Iterable</tt>.

<h2>Interface <tt>Iterator&lt;T&gt;</tt></h2>

@class-hidden Iterator

<p>An object that supports the <tt>Iterator</tt> interface performs an
iteration over the items of a composite object. It provides these methods:

@fun hasNext() as Boolean
@desc Return a boolean indicating whether there are additional objects in the
      iteration.
@end

@fun next() as T
@desc Return the next object in the iteration. The iterator interface
      does not specify the order in which objects are returned, but many
      iterable types, such as @ref{Array}, guarantee a specific iteration
      order.
@end

<h2>Interface <tt>Comparable&lt;T&gt;</tt></h2>

@class-hidden Comparable

<p><tt>Comparable</tt> defines these methods:

@fun _lt(x as T) as Boolean
@fun _gt(x as T) as Boolean
@desc A <tt>Comparable</tt> object supports comparisons using &lt; and &gt;.
@end

<h2>Interface <tt>Addable&lt;OpT, RetT&gt;</tt></h2>

@class-hidden Addable

<p><tt>Addable</tt> defines one method:

@fun _add(x as OpT) as RetT
@desc If a class implements <tt>Addable</tt>, it supports the
      + operation. The operand and result types are derived from the
      type arguments (<tt>Opt</tt> and <tt>RetT</tt>, respectively).
      <p>If the left operand <tt>o</tt> in operation <tt>o + x</tt> implements
      <tt>Addable&lt;OpT, RetT&gt;</tt>, and the right operand <tt>x</tt> is
      compatible with <tt>Opt</tt>, the result type of the operation
      <tt>RetT</tt>.

      @note A class may also support the + operation even if it does not
            implement <tt>Addable</tt>. By implementing <tt>Addable</tt>,
            the class may be used in type-safe generic operations that use
            addition.
      @end
@end

<p>@ref{Int} and @ref{Float} use <tt>Addable</tt> (for the generic +
operation).

<h2>Interface <tt>Multipliable&lt;OpT, RetT&gt;</tt></h2>

@class-hidden Multipliable

<p><tt>Multipliable</tt> defines one method:

@fun _mul(x as OpT) as RetT
@desc If a class implements <tt>Multipliable</tt>, it supports the
      * operation. The operand and result types are derived from the
      type arguments (<tt>Opt</tt> and <tt>RetT</tt>, respectively).
      @note A class may also support the * operation even if it does not
            implement <tt>Multipliable</tt>. By implementing
            <tt>Multipliable</tt>,
            the class may be used in type-safe generic operations that use
            multiplication.
      @end
@end

<p>@ref{Str} implements <tt>Multipliable</tt>.
@ref{Int} and @ref{Float} use <tt>Multipliable</tt>
(for the generic * operation).
