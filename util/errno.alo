-- errno.alo
--
-- Copyright (c) 2010-2011 Jukka Lehtosalo
--
-- Alore is licensed under the terms of the MIT license.  See the file
-- LICENSE.txt in the distribution.

-- Script for generating several errno related C definitions.
--
-- Use to generate errno_info.c and errno_info.h:
--
--   $ alore util/errno.alo --table > src/errno_info.c
--   $ alore util/errno.alo --header > src/errno_info.h
--
-- Use to generate constant definititions for error_module.c (copy & paste
-- the output to the file):
--
--   $ alore util/errno.alo --module

import io


const ErrnoIds = [
  "E2BIG" : "Argument list too long",
  "EACCES" : "Permission denied",
  "EADDRINUSE" : "Address in use",
  "EADDRNOTAVAIL" : "Local address not available",
  "EAFNOSUPPORT" : "Address family not supported",
  "EAGAIN" : "Resource temporarily unavailable",
  "EBADF" : "Bad file descriptor",
  "EBADFD" : "File descriptor in bad state",
  "EBUSY" : "Resource busy",
  "ECANCELED" : "Operation canceled",
  "ECHILD" : "No child processes",
  "ECOMM" : "Communication error on send",
  "ECONNABORTED" : "Connection aborted",
  "ECONNREFUSED" : "Connection refused",
  "EDEADLK" : "Resource deadlock avoided",
  "EDOM" : "Domain error",
  "EEXIST" : "File exists",
  "EFAULT" : "Bad address",
  "EFBIG" : "File too large",
  "EHOSTDOWN" : "Host is down",
  "EHOSTUNREACH" : "Host in unreachable",
  "EIDRM" : "Identifier removed",
  "EILSEQ" : "Illegal byte sequence",
  "EINPROGRESS" : "Operation in progress",
  "EINTR" : "Interrupted function call",
  "EINVAL" : "Invalid argument",
  "EIO" : "Input/output error",
  "EISCONN" : "Socket is connected",
  "EISDIR" : "Is a directory",
  "ELOOP" : "Too many levels of symbolic links",
  "EMFILE" : "Too many open files",
  "EMLINK" : "Too many links",
  "EMSGSIZE" : "Message too long",
  "ENAMETOOLONG" : "Filename too long",
  "ENETDOWN" : "Network is down",
  "ENETUNREACH" : "Network unreachable",
  "ENFILE" : "Too many open files",
  "ENODEV" : "No such device",
  "ENOENT" : "No such file or directory",
  "ENOEXEC" : "Exec format error",
  "ENOLCK" : "No locks available",
  "ENOLINK" : "Link has been severed",
  "ENOMEM" : "Not enough space",
  "ENOMSG" : "No message of the desired type",
  "ENONET" : "Machine is not on the network",
  "ENOPROTOOPT" : "Protocol not available",
  "ENOSPC" : "No space left on device",
  "ENOSR" : "No STREAM resources",
  "ENOSTR" : "Not a STREAM",
  "ENOSYS" : "Function not implemented",
  "ENOTCONN" : "Socket is not connected",
  "ENOTDIR" : "Not a directory",
  "ENOTEMPTY" : "Directory not empty",
  "ENOTSOCK" : "Not a socket",
  "ENOTSUP" : "Operation not supported",
  "ENOTTY" : "Inappropriate I/O control operation",
  "ENOTUNIQ" : "Name not unique on network",
  "ENXIO" : "No such device or address",
  "EOPNOTSUPP" : "Operation not supported",
  "EOVERFLOW" : "Value too large to be stored in data type",
  "EPERM" : "Operation not permitted",
  "EPIPE" : "Broken pipe",
  "EPROTO" : "Protocol error",
  "EPROTONOSUPPORT" : "Protocol not supported",
  "EPROTOTYPE" : "Protocol wrong type for socket",
  "ERANGE" : "Result too large",
  "ERESTART" : "Interrupted system call should be restarted",
  "EROFS" : "Read-only file system",
  "ESPIPE" : "Invalid seek",
  "ESRCH" : "No such process",
  "ESTALE" : "Stale file handle",
  "ETIME" : "Timer expired",
  "ETIMEDOUT" : "Operation timed out",
  "ETXTBSY" : "Text file busy",
  "EWOULDBLOCK" : "Operation would block",
  "EXDEV" : "Improper link",
]


def Main(args)
  if args.length() != 1 or not args[0] in ("--table", "--header", "--module",
                                           "--doc")
    StdErr.writeLn("Usage: errno.alo --table")
    StdErr.writeLn("  or:  errno.alo --header")
    StdErr.writeLn("  or:  errno.alo --module")
    StdErr.writeLn("  or:  errno.alo --doc")
    StdErr.writeLn()
    StdErr.writeLn("Output errno-related definitions.")
    Exit(1)
  end
  if args[0] == "--table"
    OutputTable()
  elif args[0] == "--header"
    OutputHeader()
  elif args[0] == "--module"
    OutputModule()
  else
    OutputDocumentation()
  end
end


def OutputTable()
  WriteLn("/* Automatically generated by util/errno.alo -- DO NOT MODIFY! */")
  WriteLn()
  WriteLn("#include ""aconfig.h""")
  WriteLn("#include ""errno_module.h""")
  WriteLn("#include <errno.h>")
  WriteLn()
  WriteLn("AErrnoEntry AErrnoTable[] = {")
  for p in ErrnoIds
    var id, msg = p.left, p.right
    var aid = AId(id)
    WriteLn("#ifdef {}".format(id))
    WriteLn("    {{ {}, {}, ""{}"" }},".format(aid, id, msg))
    WriteLn("#else")
    WriteLn("    {{ {}, 0, 0 }},".format(aid))
    WriteLn("#endif")
  end
  WriteLn("    { 0, 0, 0 }")
  WriteLn("};")
end


def OutputHeader()
  WriteLn("/* Automatically generated by util/errno.alo -- DO NOT MODIFY! */")
  WriteLn()
  WriteLn("#ifndef ERRNO_INFO_H")
  WriteLn("#define ERRNO_INFO_H")
  WriteLn()
  WriteLn("typedef enum {")
  var i = 0
  for p in ErrnoIds
    i += 1
    var id, msg = p.left, p.right
    WriteLn("    {} = {},".format(AId(id), i))
  end
  WriteLn("    A_ERRNO_LAST = {}".format(i))
  WriteLn("} AErrnoId;")
  WriteLn()
  WriteLn("#endif")
end


def OutputModule()
  var i = 0
  for p in ErrnoIds
    var id, msg = p.left, p.right
    i += 1
    WriteLn("    A_SYMBOLIC_CONST_P(""{}"", ErrnoNums + {})".format(id, i))
  end
end


def OutputDocumentation()
  for p in ErrnoIds
    var id, msg = p.left, p.right
    WriteLn("@var {}".format(id))
    WriteLn("@desc {}".format(msg))
    WriteLn("@end")
    WriteLn()
  end
end


def AId(id)
  return "A_ERRNO_" + id
end
