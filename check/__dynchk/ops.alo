module __dynchk

import reflect
import __testc


-- Representation of type 'dynamic'.
const __Dyn


-- Represenation of a generic type X<...>.
class __Gen
  const type
  const args
  
  def _str()
    return '__Gen({}, {})'.format(type, args)
  end
end


class AnnotationError is RuntimeError
end


-- Cast a value from source type to target type. Raise TypeFailure if the type
-- is not as expected.
def __Cast(target,  -- Cast target type
           source,  -- Cast source type
           value)   -- Value to cast
  if target == __Dyn
    -- Cast to dynamic.
    if source is __Gen
      if IsWrapped(value)
        -- If value is already wrapped, do nothing.
        return value
      else
        -- Add wrapper based on type variable.
        return Wrap(source, value)
      end
    else
      return value
    end
  elif target is __Gen
    -- Cast to a generic type. This depends on the target and source types.
    return Wrap(CombineGen(target, source), value)
  elif value is target
    return value
  elif value == nil
    return value
  else
    raise AnnotationError('{} expected, but found {}'.format(
                              target, TypeName(value)))
  end
end


-- Produce a checked generic object compatible with the requested type, or 
-- raise an exception if the value has invalid type. 
--
-- Notes:
--   1. If the input already has a suitable wrapper, return it unmodified. 
--   2. If the target type has dynamic types for all arguments, return the 
--      input value unmodified (but check that it has the correct type).
--
-- Examples (with pretty-printed arguments and results):
--
--   Wrap(A<X>, naked A)   ==> wrapped A<X>
--   Wrap(A<dyn>, naked A) ==> naked A
private def Wrap(wrapType, value) -- (__Gen, dynamic)
  var t = TypeOf(value)
  var ts = Str(t)
  if ts.endsWith('___dyn')
    -- The value to coerce is a wrapped reference.
    
    -- Make sure the value has the correct type.
    if Str(wrapType.type) != ts[:-6]
      raise AnnotationError('{} expected, but found {}'.format(
                              wrapType.type, ts[:-6]))
    end

    -- If the arguments of the target type are all dynamic, just return the 
    -- input value.
    if HasDynamicArgs(wrapType)
      return value
    end
    
    -- FIX more complex arguments
    var newArgs = []
    for i in 0 to wrapType.args.length()
      var meet = Meet(wrapType.args[i], value.__tv[i])
      if meet == nil
        raise AnnotationError('Cannot coerce {} to {}'.format(
                                PrettyStr(value), PrettyStr(wrapType)))
      end
      newArgs.append(meet)
    end
    
    var wrapper = t
    return wrapper(value.__o, newArgs)
  else
    -- The value to coerce is a naked reference. 
    
    -- Make sure the value has the correct type.
    if t != wrapType.type -- FIX
      raise AnnotationError('{} expected, but found {}'.format(
                              wrapType.type, t))
    end

    -- If the arguments of the target type are all dynamic, just return the 
    -- input value.
    if HasDynamicArgs(wrapType)
      return value
    end
    
    -- Wrap the naked value.
    var wrapper = AGlobal(ts + '___dyn')
    return wrapper(value, wrapType.args)
  end
end


-- Combine two generic types in a cast g1 <= g2. Assume that the cast is valid.
--
-- For example:
--
--   CombineGen(A<X>, A<dynamic>) == A<X>
--   CombineGen(A<dynamic>, A<X>) == A<X>
private def CombineGen(g1, g2)
  if g1 == __Dyn
    return g2
  elif g2 == __Dyn
    return g1
  elif g1 is __Gen
    -- g2 must be __Gen as well, since we have a valid cast. Both have the same
    -- base type. 
    
    -- Combine the arguments.
    var args = []
    for i in 0 to g1.args.length()
      args.append(CombineGen(g1.args[i], g2.args[i]))
    end
    
    return __Gen(g1.type, args)
  elif g1 == g2
    return g1
  else
    raise RuntimeError('Invalid cast')
  end    
end


-- Calculate the meet of two types, each of which can be a) simple types 
-- (class), b) dynamic (__Dyn) or c) __Gen instance.
private def Meet(a, b)
   -- FIX: support generic inheritance
  if a == __Dyn
    return b
  elif b == __Dyn
    return a
  elif a is __Gen
    if not b is __Gen
      -- Meet not possible (currently).
      return nil
    end
    
    -- Meet of two generic instances; must have identical base 
    -- types (currently).
    if a.type != b.type
      return nil
    end
    
    -- Calculate the meets of type arguments.
    var args = []
    for i in 0 to a.args.length()
      var meet = Meet(a.args[i], b.args[i])
      if meet == nil
        -- Could not calculate the meet of a type argument.
        return nil
      end
      args.append(meet)
    end
    
    return __Gen(a.type, args)
  elif b is __Gen
    -- a is not generic, so meet not possible (currently).
    return nil
  elif IsSubtype(a, b)
    return a
  elif IsSubtype(b, a)
    return b
  else
    return nil
  end
end


private def IsSubtype(a, b)
  while a != nil and a != b
    a = a.supertype()
  end
  return a != nil
end


-- Is the value a wrapped generic object?
private def IsWrapped(value)
  return Str(TypeOf(value)).endsWith('___dyn')
end


private def TypeName(value)
  return Str(TypeOf(value)).replace('___dyn', '')
end


private def HasDynamicArgs(t as __Gen) as Boolean
  for a in t.args
    if __Dyn != a
      return False
    end
  end
  return True
end