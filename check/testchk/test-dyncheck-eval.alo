module testchk

-- Test cases for running code that has undergone runtime checking 
-- source-to-source transformation.

import unittest
import analyse
import errors
import testchk::helpers
import dyncheck
import loader
import reflect
import io
import re
import os

-- This is used for communicating with transformed programs.
import __dynchk

import __testc -- For CallTrace


-- Name of the generated source file.
const SrcPath = '__tmp.alo'


class DyncheckEvalSuite is Suite
  -- Files that contain test case descriptions.
  const testCaseFiles = ['dyncheck-eval-basic.test',
                         'dyncheck-eval-generics.test']

  def cases()
    var c = []
    for f in testCaseFiles
      c += ParseTestCases(Join(TestDataPrefix, f), 
                          StdWrapper(TestDyncheckEval, 
                                     Join(TestDataPrefix, TransformStdModule)),
                          TestTempDir, True, 
                          Join(TestDataPrefix, 'fragments'))
    end
    return c
  end
end


-- Perform a dynamic checking evaluation test case. Transform the input 
-- program and store it in a file, evaluate the file, and verify that the
-- output of the program is as expected. The output may contain messages
-- generated with __dynch::__Print and a stack trace due to runtime failure.
private def TestDyncheckEval(testcase)
  var a
  var expected = testcase.output
  var x
  try
    var src = LF.join(testcase.input)
    -- Parse and type check the test case input.
    var trees, symtable, infos, types = 
                 Analyse(src, "main", False, TestTempDir, True)
    a = []
    var first = True
    -- Transform all the input source files.
    for t in trees
      if not t.path.endsWith("/std.alo") and not "-skip." in t.path
        if not first
          a.append("{}:".format(RemovePrefix(t.path, TestTempDir)))
        end
      
        -- Transform a source file.
        var v = DyncheckTransformVisitor(types, False)
        t.accept(v)
        var v2 = PrettyPrintVisitor(False, v.lineMap)
        t.accept(v2)
        var s = v2.output()
        x = s
        
        -- Write the transformed file. Note that we currently only support a
        -- single output file.
        var f = File(SrcPath, Output)
        f.writeLn('import __dynchk')
        f.write(s)
        f.close()
        
        -- Load and evaluate the transformed file.
        var e, extra = CallTrace(Load, SrcPath)
        
        -- Get the output of the evaluation.
        a = __dynchk::__GetOutput()
        
        if e is AnnotationError
          -- The evaluation was aborted due to an runtime type error. Add the
          -- stack trace to the output.
          
          -- Offset 1 is due to the extra 'import __dynchk' line.
          a += FormatStackTrace(extra, e, v2.lineMap(), 1)
        elif e != nil
          raise e
        end
        
        try
          -- Clean up now that the evaluation is finished.
          Remove(SrcPath)
        except IoError
        end
      end
      first = False
    end
  except e is errors::CompileError
    a = e.messages
  except e is loader::CompileError
    Print(x)
    a = e.errorMessages
  end
  AssertStringArraysEqualWildcards(expected, a, 
                          "Invalid source code output ({}, line {})".format(
                            testcase.file, testcase.line))
end


-- Clean up a stack trace produced by an evaluation. Remove some lines that
-- refer to operations in the __dynchk module, and replace mangled names with
-- the original names. Also fix the line numbers to refer to the original
-- file (most of the time; the algorithm is not fully robust).
private def FormatStackTrace(trace, e, lineMap, offset)
  trace = Reversed(trace[:-1])
  while trace != [] and trace[-1].startsWith('__dynchk::')
    trace.removeAt(-1)
  end
  for i in 0 to trace.length()
    trace[i] = '  ' + trace[i]
    trace[i] = Subst(trace[i], '([a-zA-Z0-9_]*[a-zA-Z0-9])__[a-zA-Z0-9_]+', 
                     '\1')
    
    trace[i] = FixLineNumbers(trace[i], SrcPath, lineMap, offset)
    
  end
  return ['Traceback:'] + trace+ 
         ['AnnotationError: {}'.format(e.message)]
end


-- Replace line number in a traceback line that refers to the transformed
-- program with a corresponding line number in the original program. 
-- Note that this does may not work always perfectly.
--
-- The map argument describes the line number mapping.
private def FixLineNumbers(str, fnam, map, offset)
  return Subst(str, '({}, line )([0-9]+)'.format(fnam),
               def (m)
                 var delta = 0
                 var line = Int(m.group(2))
                 for orig, new in map
                   if new < line
                     delta = orig - new
                   end
                 end
                 return m.group(1) + Str(line + delta - offset)
               end) 
end
