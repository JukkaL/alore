module testchk::dynchkops

-- Definitions needed by DyncheckOpsSuite and a test fixture class that sets
-- up objects for use by the test cases. 
--
-- TODO:
--  - it would be better if the definitions could be private; the ops may have
--    to be modified for this
--
-- The definitions have a similar structure to definitions produced by runtime
-- checking program transformation, but they only have the minimal 
-- functionality required by the test cases.

import __dynchk


private class OpsFixture
  -- Generic types (single type arg)
  
  -- G
  const g_a_t = __Gen(G, [A])           -- G<A>
  const g_b_t = __Gen(G, [B])           -- G<B>
  const g_dyn_t = __Gen(G, [Dyn])       -- G<dynamic>
  const g_obj_t = __Gen(G, [Object])    -- G<Object>
  const g_aa_t = __Gen(G, [AA])         -- G<AA>
  const g_g_a_t = __Gen(G, [g_a_t])     -- G<G<A>>
  const g_g_aa_t = __Gen(G, [g_aa_t])   -- G<G<A>>
  const g_g_dyn_t = __Gen(G, [g_dyn_t]) -- G<G<dynamic>>
  -- H
  const h_a_t = __Gen(H, [A])        -- H<A>
  const h_b_t = __Gen(H, [B])        -- H<B>
  
  -- Generic types (multiple type args)
  
  -- M
  const m_a_a_t = __Gen(M, [A, A])         -- M<A, A>
  const m_a_b_t = __Gen(M, [A, B])         -- M<A, B>
  const m_b_a_t = __Gen(M, [B, A])         -- M<B, A>
  const m_aa_b_t = __Gen(M, [AA, B])       -- M<AA, B>
  const m_b_aa_t = __Gen(M, [B, AA])       -- M<B, AA>
  const m_dyn_a_t = __Gen(M, [Dyn, A])     -- M<dynamic, A>
  const m_dyn_aa_t = __Gen(M, [Dyn, AA])   -- M<dynamic, AA>
  const m_a_dyn_t = __Gen(M, [A, Dyn])     -- M<A, dynamic>
  const m_b_dyn_t = __Gen(M, [B, Dyn])     -- M<B, dynamic>
  const m_dyn_dyn_t = __Gen(M, [Dyn, Dyn]) -- M<dynamic, dynamic>  
  
  -- Instances of non-generic types
  const o = Object()
  const a = A()
  const b = B()
  const aa = AA()
  const ab = AB()
  
  -- Naked instances of generic types
  const g_naked = G()
  const h_naked = H()
  const m_naked = M()
  
  -- Wrapped instances of generic types (single type arg)
  
  -- G
  const g_a = G___dyn(g_naked, [A])        -- G<A>
  const g_b = G___dyn(g_naked, [B])        -- G<B>
  const g_obj = G___dyn(g_naked, [Object]) -- G<Object>
  const g_aa = G___dyn(g_naked, [AA])      -- G<AA>
  const g_ba = G___dyn(g_naked, [BA])      -- G<BA>
  const g_g_a = G___dyn(g_naked, [g_a_t])  -- G<G<A>>
  const g_g_aa = G___dyn(g_naked, [g_aa_t])-- G<G<AA>>
  const g_g_b = G___dyn(g_naked, [g_b_t])  -- G<G<B>>
  const g_g_dyn = G___dyn(g_naked, [g_dyn_t]) -- G<G<dyn>>
  -- H
  const h_a = H___dyn(h_naked, [A])        -- G<A>
  const h_b = H___dyn(h_naked, [B])        -- G<B>
  -- Mixed
  const g_h_a = G___dyn(h_naked, [h_a_t])  -- G<H<A>>
  
  -- Wrapped instances of generic types (multiple type args)
  
  -- M
  const m_a_a = M___dyn(m_naked, [A, A])      -- M<A, A>
  const m_a_b = M___dyn(m_naked, [A, B])      -- M<A, B>
  const m_b_a = M___dyn(m_naked, [B, A])      -- M<B, A>
  const m_aa_b = M___dyn(m_naked, [AA, B])    -- M<AA, B>
  const m_b_aa = M___dyn(m_naked, [B, AA])    -- M<B, AA>
  const m_dyn_a = M___dyn(m_naked, [Dyn, A])  -- M<dynamic, A>
  const m_dyn_aa = M___dyn(m_naked, [Dyn, AA])-- M<dynamic, AA>
  const m_a_dyn = M___dyn(m_naked, [A, Dyn])  -- M<A, dynamic>
  const m_b_dyn = M___dyn(m_naked, [B, Dyn])  -- M<B, dynamic>
end


class A
end

class B
end

class AA is A
end

class AB is A
end

class BA is B
end


class G
  def _str()
    return 'G()'
  end
end

class G___dyn
  var __o
  var __tv
  
  def _str()
    return 'G___dyn({}, {})'.format(__o, __tv)
  end
end


class H
  def _str()
    return 'H()'
  end
end

class H___dyn
  var __o
  var __tv
  
  def _str()
    return 'H___dyn({}, {})'.format(__o, __tv)
  end
end


class M
  def _str()
    return 'M()'
  end
end

class M___dyn
  var __o
  var __tv
  
  def _str()
    return 'M___dyn({}, {})'.format(__o, __tv)
  end
end
