module dyncheck

import output
import types
import string
import nodes


-- Class for converting transformed parse trees into source code. Pretty print
-- nodes created in transformation using default formatting, as these nodes may
-- not have representations.
class PrettyPrintVisitor is OutputVisitor
  private const isPretty
  private const lineAssoc = [] as Array<(Int, Int)>
  private const nodeLineMap as Map<Node, (Int, Int)>
  
  
  def create(isPretty = True, nodeLineMap = Map())
    self.isPretty = isPretty
    self.nodeLineMap = nodeLineMap
    super.create()
  end
  
  
  def lineMap()
    return Sort(self.lineAssoc, def (x, y); return x[1] < y[1]; end)
  end


  -- Definitions
  -- -----------

  
  def visitTypeDef(tdef)
    if tdef.repr != nil
      super.visitTypeDef(tdef)
      addLineMapping(tdef.repr.endBr)
    else
      -- The type does not have an explicit representation: it must have been
      -- created during the transformation.
      
      -- FIX implements etc.
      if lastOutputChar() != LF
        str(LF)
      end
      var start = line()
      if tdef.isPrivate
        str('private ')
      end
      str('class ')
      str(tdef.name)
      if tdef.base != nil
        str(' is ')
        node(tdef.base)
      end
      str(LF)
      for d in tdef.defs
        d.accept(self)
      end
      addNodeLineMapping(tdef, start, line())
      str('end' + LF)
    end
  end      
  
  def visitFuncDef(fdef)
    if fdef.repr != nil
      addLineMapping(fdef.repr.defTok)
    end
    if fdef.repr != nil or (fdef.isConstructor() and fdef.info.typeVars == [])
      super.visitFuncDef(fdef)
    else
      -- The function does not have an explicit representation. It must have
      -- been created during the transformation.
    
      -- FIX private, varargs, default args etc.
      var start = line()
      str('  def ')
      str(fdef.name)
      if not fdef.isAccessor()
        str('(')
        for i in 0 to fdef.args.length()
          var a = fdef.args[i]
          str(a.name)
          str(' as ')
          omitNextSpace = True
          type(fdef.type.type.argTypes[i])
          if i < fdef.args.length() - 1
            str(', ')
          end
        end
        str(')')
        if not fdef.type.type.retType is Void
          str(' as ')
          omitNextSpace = True
          type(fdef.type.type.retType)
        end
      else
        str(' as ')
        omitNextSpace = True
        type(fdef.type.type)
      end
      str(LF)
      nodes(fdef.body)
      addNodeLineMapping(fdef, start, line())
      str('  end' + LF)
    end
  end
  
  def visitVarDef(vdef)
    if vdef.repr != nil
      super.visitVarDef(vdef)
    else
      -- No explicit representation. It node was created during transformation.
      str('  ')       
      if vdef.isPrivate
        str('private ')
      end
      if vdef.isConst
        str('const ')
      else
        str('var ')
      end
      str(vdef.names[0].name)
      str(' as ')
      str(Str(vdef.type.type))
      str(LF)
    end
  end


  -- Statements
  -- ----------
  

  def visitReturnStmt(o)
    if o.repr != nil
      super.visitReturnStmt(o)
    else
      -- No explicit representation. Use automatic formatting.
      str('    return ')
      omitNextSpace = True
      node(o.expr)
      str(LF)
    end
  end
  
  def visitExpressionStmt(o)
    if o.repr != nil
      super.visitExpressionStmt(o)
    else
      -- No explicit representation. Use automatic formatting.
      str('    ')
      omitNextSpace = True
      node(o.expr)
      str(LF)
    end
  end
  
  def visitAssignmentStmt(o)
    if o.repr != nil
      super.visitAssignmentStmt(o)
    else
      -- No explicit representation. Use automatic formatting.
      str('    ')
      omitNextSpace = True
      node(o.lvalues[0]) -- FIX multiple lvalues
      str(' = ')
      node(o.rvalue)
      str(LF)      
    end
  end
  
  
  -- Expressions
  -- -----------
  
  
  def visitCallExpr(o)
    if o.repr != nil
      super.visitCallExpr(o)
    else
      -- No explicit representation. Use automatic formatting.
      node(o.callee)
      str('(')
      omitNextSpace = True
      for i in 0 to o.args.length()
        node(o.args[i])
        if i < o.args.length() - 1
          str(', ')
        end
      end
      str(')')
    end
  end
  
  def visitMemberExpr(o)
    if o.repr != nil
      super.visitMemberExpr(o)
    else
      -- No explicit representation. Use automatic formatting.
      node(o.expr)
      str('.' + o.name)
    end
  end
  
  def visitMemberLvalue(o)
    if o.repr != nil
      super.visitMemberLvalue(o)
    else
      -- No explicit representation. Use automatic formatting.
      visitMemberExpr(o)
    end
  end
  
  def visitNameExpr(o)
    if o.repr != nil
      super.visitNameExpr(o)
    else
      -- No explicit representation. Use automatic formatting.
      str(o.name)
    end
  end
  
  def visitSelfExpr(o)
    if o.repr != nil
      super.visitSelfExpr(o)
    else
      -- No explicit representation. Use automatic formatting.
      str('self')
    end
  end
  
  def visitCoerceExpr(o)
    -- Coercions are always generated during trasnformation so they do not
    -- have a representation. Thus always use automatic formatting.
    var last = lastOutputChar()
    if last in (',', '=') or IsWordChar(last)
      str(' ')
    end
    if self.isPretty
      str('{')
      omitNextSpace = True
      compactType(o.targetType)
      str(' <= ')
      omitNextSpace = True
      compactType(o.sourceType)
      str(' | ')
      omitNextSpace = True
      node(o.expr)
      str('}')
    else
      str('__Cast(')
      omitNextSpace = True
      compactType(o.targetType)
      str(', ')
      omitNextSpace = True
      compactType(o.sourceType)
      str(', ')
      omitNextSpace = True
      node(o.expr)
      str(')')
    end
  end
  
  def visitTypeExpr(o)
    -- Type expressions are only generated during transformation, so we must
    -- use automatic formatting.
    str('[')
    var n = o.types.length()
    for i in 0 to n
      compactType(o.types[i])
      if i < n - 1
        str(', ')
      end
    end
    str(']')
  end
  
  def visitIndexExpr(o)
    if o.repr != nil
      super.visitIndexExpr(o)
    else
      -- No explicit representation. Use automatic formatting.
      node(o.base)
      str('[')
      omitNextSpace = True
      node(o.index)
      str(']')
    end
  end
  
  def visitIntExpr(o)
    -- IDEA: Try to use explicit representation?
    str(' ')
    str(Str(o.value))
  end
  
  
  -- Helpers
  -- -------
  

  -- Pretty-print a type using original formatting.  
  def type(t)
    if t != nil
      var v = TypePrettyPrintVisitor()
      t.accept(v)
      str(v.output())
    end
  end
  
  -- Pretty-print a type using automatic formatting.
  def compactType(t)
    if t != nil
      str(t.accept(PrettyTypeStrVisitor(self.isPretty)))
    end
  end
  
  -- Record a line mapping between the current output line and the line of
  -- the token.
  def addLineMapping(token)
    self.lineAssoc.append((token.line + token.str.count(LF), line()))
  end
  
  def addNodeLineMapping(node, start, stop)
    if self.nodeLineMap.hasKey(node)
      var start2, stop2 = self.nodeLineMap[node]
      self.lineAssoc.append((start2, start))
      self.lineAssoc.append((stop2, stop))
    end
  end
end
