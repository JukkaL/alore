module dyncheck

-- Utility functions used by the dynamic checking source-to-source 
-- transformation.

import types
import nodes
import lex


-- Prepend an argument with the given type to a callable type.
def PrependArgType(t as Callable, argType as Typ) as Callable
  return Callable([argType] + t.argTypes,
                  t.minArgs + 1,
                  t.isVarArg, t.retType, t.isTypeObj, t.name, t.variables,
                  t.boundVars, t.line, nil)
end


-- Return a copy of a callable type with a different return type.
def ReplaceRetType(t as Callable, retType as Typ) as Callable
  return Callable(t.argTypes, t.minArgs, t.isVarArg, retType, t.isTypeObj,
                  t.name, t.variables, t.boundVars, t.line, nil)
end


-- Translate callable type to type erased (dynamically-typed) callable type
-- with the same number of arguments.
def DynamicSig(sig as Callable) as Callable
  return Callable([Dynamic()] * sig.argTypes.length(),
                  sig.minArgs,
                  sig.isVarArg,
                  Dynamic(),
                  sig.isTypeObj)
end


-- Prepend an argument with the given name to a representation of a function.
-- Or if frepr == nil, return nil. 
def PrependArgRepr(frepr as FuncRepr, name as Str) as FuncRepr
  if frepr == nil
    return nil
  end
  -- Add the argument to all (intersection) items in the representation.
  var args = [] as <FuncArgsRepr>
  for ar in frepr.args
    -- We may need to add a comma as well.
    var commas = [Token('')]
    if ar.argNames.length() > 0
      commas = [Token(', ')] + ar.commas
    end
    args.append(FuncArgsRepr(
                  ar.lseparator, ar.rseparator, 
                  [Token(name)] + ar.argNames,
                  commas,
                  [Token('')] + ar.assigns,
                  ar.asterisk,
                  [Token(' as')] + ar.asToks,
                  ar.orTok))
  end
  var r = frepr
  return FuncRepr(r.visibility, r.defTok, r.name, args, r.defBr, r.endTok,
                  r.endBr)
end


-- If fdef has a representation, return a copy of the representation with the
-- given name substituted for the original name. Otherwise, return nil.
def FuncReprWithName(fdef as FuncDef, name as Str) as FuncRepr
  var r = fdef.repr
  if r == nil
    return r
  else
    return FuncRepr(r.visibility, r.defTok, Token(name, r.name.pre),
                    r.args, r.defBr, r.endTok, r.endBr)
  end
end


-- Prepend an argument to the representation of a call expression with the
-- given number of arguments.
def PrependCallArgRepr(r as CallExprRepr, argc as Int) as CallExprRepr
  -- Actually only add a comma token (if there are any original arguments)
  -- since the representations of the argument expressions are stored with
  -- the relevant expression nodes.
  var commas = [] as <Token>
  if argc > 0
    commas = [Token(', ')] + r.commas
  end
  return CallExprRepr(r.lparen, commas, r.asterisk, r.rparen)
end


-- Translate any type variables in a type into wrapper type variables (i.e. 
-- into type variables that refer to values stored in a generic class wrapper).
def TranslateTypeVarsToWrapperVars(type as Typ) as Typ
  return type.accept(TranslateTypeVarsToWrapperVarsVisitor())
end


-- Visitor that implements TranslateTypeVarsToWrapperVarsVisitor.
private class TranslateTypeVarsToWrapperVarsVisitor is TypeTranslator
  def visitTypeVar(t as TypeVar) as Typ
    return TypeVar(t.name, t.id, True, t.line, t.repr)
  end
end


-- Is a function a method of a generic type? (Note that this may return False
-- even if the function itself is generic.)
def IsGeneric(fdef as FuncDef) as Boolean
  return fdef.info != nil and fdef.info.typeVars != []
end
